# åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡æœ€ä½³å®è·µ

æœ¬æ–‡æ¡£æ€»ç»“äº†åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡ä¸­çš„æœ€ä½³å®è·µï¼Œå¸®åŠ©æ‚¨æ„å»ºå¯é ã€é«˜æ€§èƒ½ã€å¯æ‰©å±•çš„åˆ†å¸ƒå¼åº”ç”¨ã€‚

## ç›®å½•

- [åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡æœ€ä½³å®è·µ](#åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡æœ€ä½³å®è·µ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ—ï¸ æ¶æ„è®¾è®¡åŸåˆ™](#ï¸-æ¶æ„è®¾è®¡åŸåˆ™)
    - [1. å•ä¸€èŒè´£åŸåˆ™](#1-å•ä¸€èŒè´£åŸåˆ™)
    - [2. æ¥å£éš”ç¦»åŸåˆ™](#2-æ¥å£éš”ç¦»åŸåˆ™)
    - [3. ä¾èµ–å€’ç½®åŸåˆ™](#3-ä¾èµ–å€’ç½®åŸåˆ™)
  - [ğŸ”„ ä¸€è‡´æ€§è®¾è®¡](#-ä¸€è‡´æ€§è®¾è®¡)
    - [1. é€‰æ‹©åˆé€‚çš„ä¸€è‡´æ€§çº§åˆ«](#1-é€‰æ‹©åˆé€‚çš„ä¸€è‡´æ€§çº§åˆ«)
    - [2. å®ç°è¯»ä¿®å¤æœºåˆ¶](#2-å®ç°è¯»ä¿®å¤æœºåˆ¶)
  - [ğŸ—³ï¸ å…±è¯†ç®—æ³•è®¾è®¡](#ï¸-å…±è¯†ç®—æ³•è®¾è®¡)
    - [1. åˆç†é…ç½®é€‰ä¸¾è¶…æ—¶](#1-åˆç†é…ç½®é€‰ä¸¾è¶…æ—¶)
    - [2. å®ç°æ—¥å¿—å‹ç¼©](#2-å®ç°æ—¥å¿—å‹ç¼©)
  - [ğŸ’° åˆ†å¸ƒå¼äº‹åŠ¡è®¾è®¡](#-åˆ†å¸ƒå¼äº‹åŠ¡è®¾è®¡)
    - [1. é€‰æ‹©åˆé€‚çš„åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼](#1-é€‰æ‹©åˆé€‚çš„åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼)
    - [2. å®ç°å¹‚ç­‰æ€§](#2-å®ç°å¹‚ç­‰æ€§)
  - [ğŸ” æ•…éšœæ£€æµ‹è®¾è®¡](#-æ•…éšœæ£€æµ‹è®¾è®¡)
    - [1. å®ç°å¤šçº§æ•…éšœæ£€æµ‹](#1-å®ç°å¤šçº§æ•…éšœæ£€æµ‹)
    - [2. å®ç°æ•…éšœæ¢å¤](#2-å®ç°æ•…éšœæ¢å¤)
  - [âš–ï¸ è´Ÿè½½å‡è¡¡è®¾è®¡](#ï¸-è´Ÿè½½å‡è¡¡è®¾è®¡)
    - [1. é€‰æ‹©åˆé€‚çš„è´Ÿè½½å‡è¡¡ç®—æ³•](#1-é€‰æ‹©åˆé€‚çš„è´Ÿè½½å‡è¡¡ç®—æ³•)
    - [2. å®ç°å¥åº·æ£€æŸ¥](#2-å®ç°å¥åº·æ£€æŸ¥)
  - [ğŸ›¡ï¸ å®‰å…¨è®¾è®¡](#ï¸-å®‰å…¨è®¾è®¡)
    - [1. å®ç°è®¤è¯å’Œæˆæƒ](#1-å®ç°è®¤è¯å’Œæˆæƒ)
    - [2. å®ç°æ•°æ®åŠ å¯†](#2-å®ç°æ•°æ®åŠ å¯†)
  - [ğŸ“Š ç›‘æ§è®¾è®¡](#-ç›‘æ§è®¾è®¡)
    - [1. å®ç°æŒ‡æ ‡æ”¶é›†](#1-å®ç°æŒ‡æ ‡æ”¶é›†)
    - [2. å®ç°é“¾è·¯è¿½è¸ª](#2-å®ç°é“¾è·¯è¿½è¸ª)
  - [ğŸš€ æ€§èƒ½ä¼˜åŒ–](#-æ€§èƒ½ä¼˜åŒ–)
    - [1. å®ç°è¿æ¥æ± ](#1-å®ç°è¿æ¥æ± )
    - [2. å®ç°æ‰¹å¤„ç†](#2-å®ç°æ‰¹å¤„ç†)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
  - [ğŸ†˜ è·å–å¸®åŠ©](#-è·å–å¸®åŠ©)

## ğŸ—ï¸ æ¶æ„è®¾è®¡åŸåˆ™

> å¼•ç”¨ï¼šClean Architectureã€Google SREã€DDIAï¼ˆDesigning Data-Intensive Applicationsï¼‰ã€Microservices Patternsã€‚

### 1. å•ä¸€èŒè´£åŸåˆ™

æ¯ä¸ªç»„ä»¶åº”è¯¥åªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„åŠŸèƒ½ï¼Œé¿å…åŠŸèƒ½è€¦åˆã€‚

```rust
// âœ… å¥½çš„è®¾è®¡ï¼šèŒè´£åˆ†ç¦»
struct ReplicationManager {
    replicator: LocalReplicator,
    consistency_checker: ConsistencyChecker,
}

struct ConsistencyChecker {
    level: ConsistencyLevel,
    quorum_calculator: QuorumCalculator,
}

// âŒ ä¸å¥½çš„è®¾è®¡ï¼šèŒè´£æ··ä¹±
struct DistributedStorage {
    replicator: LocalReplicator,
    load_balancer: RoundRobinBalancer,
    circuit_breaker: CircuitBreaker,
    metrics_collector: MetricsCollector,
    // å¤ªå¤šèŒè´£ï¼
}
```

### 2. æ¥å£éš”ç¦»åŸåˆ™

å®šä¹‰æ¸…æ™°ã€æœ€å°åŒ–çš„æ¥å£ï¼Œé¿å…å®¢æˆ·ç«¯ä¾èµ–ä¸éœ€è¦çš„æ–¹æ³•ã€‚

```rust
// âœ… å¥½çš„è®¾è®¡ï¼šæ¥å£éš”ç¦»
trait Readable {
    async fn read(&self, key: &str) -> Result<Option<Vec<u8>>, Error>;
}

trait Writable {
    async fn write(&self, key: &str, value: &[u8]) -> Result<(), Error>;
}

trait Replicatable: Readable + Writable {
    async fn replicate(&self, key: &str, value: &[u8], level: ConsistencyLevel) -> Result<(), Error>;
}

// âŒ ä¸å¥½çš„è®¾è®¡ï¼šæ¥å£è‡ƒè‚¿
trait DistributedStorage {
    async fn read(&self, key: &str) -> Result<Option<Vec<u8>>, Error>;
    async fn write(&self, key: &str, value: &[u8]) -> Result<(), Error>;
    async fn delete(&self, key: &str) -> Result<(), Error>;
    async fn list(&self, prefix: &str) -> Result<Vec<String>, Error>;
    async fn backup(&self, path: &str) -> Result<(), Error>;
    async fn restore(&self, path: &str) -> Result<(), Error>;
    // å¤ªå¤šæ–¹æ³•ï¼
}
```

### 3. ä¾èµ–å€’ç½®åŸåˆ™

ä¾èµ–æŠ½è±¡è€Œä¸æ˜¯å…·ä½“å®ç°ï¼Œä¾¿äºæµ‹è¯•å’Œæ‰©å±•ã€‚

```rust
// âœ… å¥½çš„è®¾è®¡ï¼šä¾èµ–æŠ½è±¡
trait StorageBackend {
    async fn get(&self, key: &str) -> Result<Option<Vec<u8>>, Error>;
    async fn put(&self, key: &str, value: &[u8]) -> Result<(), Error>;
}

struct DistributedStorage {
    backend: Box<dyn StorageBackend + Send + Sync>,
}

impl DistributedStorage {
    fn new(backend: Box<dyn StorageBackend + Send + Sync>) -> Self {
        Self { backend }
    }
}

// âŒ ä¸å¥½çš„è®¾è®¡ï¼šä¾èµ–å…·ä½“å®ç°
struct DistributedStorage {
    redis_client: RedisClient,
    postgres_client: PostgresClient,
}
```

## ğŸ”„ ä¸€è‡´æ€§è®¾è®¡

> å‚è€ƒï¼šGilbert & Lynch (CAP)ã€PACELC (Abadi)ã€Adya et al. on Isolation Levelsã€‚

### 1. é€‰æ‹©åˆé€‚çš„ä¸€è‡´æ€§çº§åˆ«

æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©åˆé€‚çš„ä¸€è‡´æ€§çº§åˆ«ã€‚

```rust
// å¼ºä¸€è‡´æ€§ï¼šé‡‘èäº¤æ˜“
let financial_config = ConsistencyConfig {
    level: ConsistencyLevel::Strong,
    quorum_reads: true,
    quorum_writes: true,
    read_timeout: Duration::from_millis(100),
    write_timeout: Duration::from_millis(200),
};

// æœ€ç»ˆä¸€è‡´æ€§ï¼šç”¨æˆ·é…ç½®
let config_config = ConsistencyConfig {
    level: ConsistencyLevel::Eventual,
    quorum_reads: false,
    quorum_writes: true,
    read_timeout: Duration::from_millis(500),
    write_timeout: Duration::from_millis(1000),
};

// ä¼šè¯ä¸€è‡´æ€§ï¼šç”¨æˆ·ä¼šè¯
let session_config = ConsistencyConfig {
    level: ConsistencyLevel::Session,
    quorum_reads: false,
    quorum_writes: true,
    read_timeout: Duration::from_millis(200),
    write_timeout: Duration::from_millis(300),
};
```

### 2. å®ç°è¯»ä¿®å¤æœºåˆ¶

è‡ªåŠ¨æ£€æµ‹å’Œä¿®å¤æ•°æ®ä¸ä¸€è‡´ã€‚

```rust
struct ReadRepairManager {
    replicator: LocalReplicator,
    consistency_checker: ConsistencyChecker,
}

impl ReadRepairManager {
    async fn read_with_repair(&self, key: &str) -> Result<Option<Vec<u8>>, Error> {
        // 1. ä»å¤šä¸ªå‰¯æœ¬è¯»å–
        let replicas = self.replicator.get_replicas(key);
        let mut values = Vec::new();
        
        for replica in replicas {
            match replica.read(key).await {
                Ok(value) => values.push(value),
                Err(e) => tracing::warn!("å‰¯æœ¬è¯»å–å¤±è´¥: {}", e),
            }
        }
        
        // 2. æ£€æŸ¥ä¸€è‡´æ€§
        if let Some(inconsistent_replicas) = self.consistency_checker.check(&values) {
            // 3. æ‰§è¡Œè¯»ä¿®å¤
            self.repair_inconsistent_replicas(key, &inconsistent_replicas).await?;
        }
        
        // 4. è¿”å›æœ€æ–°å€¼
        Ok(self.consistency_checker.get_latest(&values))
    }
    
    async fn repair_inconsistent_replicas(&self, key: &str, replicas: &[Replica]) -> Result<(), Error> {
        let latest_value = self.consistency_checker.get_latest(&values);
        
        for replica in replicas {
            if let Err(e) = replica.write(key, &latest_value).await {
                tracing::error!("è¯»ä¿®å¤å¤±è´¥: {}", e);
            }
        }
        
        Ok(())
    }
}
```

## ğŸ—³ï¸ å…±è¯†ç®—æ³•è®¾è®¡

> å‚è€ƒï¼šRaft (2014)ã€Paxos (1998)ã€EPaxos (2013)ã€Raft Refloated (2015)ã€‚

### 1. åˆç†é…ç½®é€‰ä¸¾è¶…æ—¶

é¿å…é¢‘ç¹é€‰ä¸¾å’Œè„‘è£‚ã€‚

```rust
// âœ… å¥½çš„é…ç½®ï¼šåˆç†çš„è¶…æ—¶è®¾ç½®
let raft_config = RaftConfig {
    election_timeout_min: Duration::from_millis(150),
    election_timeout_max: Duration::from_millis(300),
    heartbeat_interval: Duration::from_millis(50),
    // é€‰ä¸¾è¶…æ—¶æ˜¯å¿ƒè·³é—´éš”çš„ 3-6 å€
};

// âŒ ä¸å¥½çš„é…ç½®ï¼šè¶…æ—¶è®¾ç½®ä¸å½“
let raft_config = RaftConfig {
    election_timeout_min: Duration::from_millis(100),
    election_timeout_max: Duration::from_millis(150),
    heartbeat_interval: Duration::from_millis(50),
    // é€‰ä¸¾è¶…æ—¶å¤ªçŸ­ï¼Œå®¹æ˜“é¢‘ç¹é€‰ä¸¾
};
```

### 2. å®ç°æ—¥å¿—å‹ç¼©

å®šæœŸå‹ç¼©æ—¥å¿—ï¼Œé¿å…æ—¥å¿—æ— é™å¢é•¿ã€‚

```rust
struct LogCompactor {
    storage: LogStorage,
    snapshot_threshold: usize,
    compaction_interval: Duration,
}

impl LogCompactor {
    async fn start_compaction(&self) -> Result<(), Error> {
        let mut interval = tokio::time::interval(self.compaction_interval);
        
        loop {
            interval.tick().await;
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦å‹ç¼©
            if self.storage.log_size() > self.snapshot_threshold {
                self.compact_logs().await?;
            }
        }
    }
    
    async fn compact_logs(&self) -> Result<(), Error> {
        // 1. åˆ›å»ºå¿«ç…§
        let snapshot = self.storage.create_snapshot().await?;
        
        // 2. æˆªæ–­æ—§æ—¥å¿—
        self.storage.truncate_logs(snapshot.last_applied_index).await?;
        
        // 3. ä¿å­˜å¿«ç…§
        self.storage.save_snapshot(snapshot).await?;
        
        tracing::info!("æ—¥å¿—å‹ç¼©å®Œæˆï¼Œæˆªæ–­åˆ°ç´¢å¼• {}", snapshot.last_applied_index);
        Ok(())
    }
}
```

## ğŸ’° åˆ†å¸ƒå¼äº‹åŠ¡è®¾è®¡

> å‚è€ƒï¼šSagas (1987)ã€TCC æ¨¡å¼ã€Spanner/TrueTimeã€FaunaDB äº‹åŠ¡æ¨¡å‹ã€‚

### 1. é€‰æ‹©åˆé€‚çš„åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼

æ ¹æ®ä¸šåŠ¡åœºæ™¯é€‰æ‹©åˆé€‚çš„äº‹åŠ¡æ¨¡å¼ã€‚

```rust
// Saga æ¨¡å¼ï¼šé•¿äº‹åŠ¡ï¼Œæœ€ç»ˆä¸€è‡´æ€§
struct OrderSaga {
    steps: Vec<Box<dyn SagaStep>>,
    compensation_log: Vec<CompensationAction>,
}

impl OrderSaga {
    async fn execute(&mut self) -> Result<(), Error> {
        for (i, step) in self.steps.iter_mut().enumerate() {
            match step.execute().await {
                Ok(_) => {
                    // è®°å½•è¡¥å¿åŠ¨ä½œ
                    self.compensation_log.push(CompensationAction {
                        step_index: i,
                        compensation: step.compensate(),
                    });
                }
                Err(e) => {
                    // æ‰§è¡Œè¡¥å¿
                    self.compensate().await?;
                    return Err(e);
                }
            }
        }
        Ok(())
    }
}

// 2PC æ¨¡å¼ï¼šçŸ­äº‹åŠ¡ï¼Œå¼ºä¸€è‡´æ€§
struct TwoPhaseCommitCoordinator {
    participants: Vec<Participant>,
    transaction_log: TransactionLog,
}

impl TwoPhaseCommitCoordinator {
    async fn execute_transaction(&mut self, operations: Vec<Operation>) -> Result<(), Error> {
        // Phase 1: Prepare
        let mut prepared_participants = Vec::new();
        
        for (i, participant) in self.participants.iter().enumerate() {
            match participant.prepare(&operations[i]).await {
                Ok(_) => prepared_participants.push(i),
                Err(e) => {
                    // Abort æ‰€æœ‰å·²å‡†å¤‡çš„å‚ä¸è€…
                    self.abort_prepared(&prepared_participants).await?;
                    return Err(e);
                }
            }
        }
        
        // Phase 2: Commit
        for participant_index in prepared_participants {
            self.participants[participant_index].commit().await?;
        }
        
        Ok(())
    }
}
```

### 2. å®ç°å¹‚ç­‰æ€§

ç¡®ä¿æ“ä½œå¯ä»¥å®‰å…¨é‡è¯•ã€‚

```rust
struct IdempotentOperation {
    operation_id: String,
    storage: IdempotencyStore,
}

impl IdempotentOperation {
    async fn execute<T, F>(&self, operation: F) -> Result<T, Error>
    where
        F: Fn() -> Result<T, Error>,
    {
        // æ£€æŸ¥æ˜¯å¦å·²æ‰§è¡Œ
        if let Some(result) = self.storage.get(&self.operation_id).await? {
            return Ok(result);
        }
        
        // æ‰§è¡Œæ“ä½œ
        let result = operation()?;
        
        // è®°å½•ç»“æœ
        self.storage.put(&self.operation_id, &result).await?;
        
        Ok(result)
    }
}
```

## ğŸ” æ•…éšœæ£€æµ‹è®¾è®¡

> å‚è€ƒï¼šSWIM (2002)ã€Lifeguardã€‚

### 1. å®ç°å¤šçº§æ•…éšœæ£€æµ‹

ç»“åˆç›´æ¥æ¢æµ‹å’Œé—´æ¥æ¢æµ‹ã€‚

```rust
struct MultiLevelFailureDetector {
    direct_detector: DirectFailureDetector,
    indirect_detector: IndirectFailureDetector,
    gossip_protocol: GossipProtocol,
}

impl MultiLevelFailureDetector {
    async fn detect_failure(&self, target: NodeId) -> Result<FailureStatus, Error> {
        // 1. ç›´æ¥æ¢æµ‹
        match self.direct_detector.ping(target).await {
            Ok(_) => return Ok(FailureStatus::Alive),
            Err(_) => {
                // 2. é—´æ¥æ¢æµ‹
                match self.indirect_detector.ping_req(target).await {
                    Ok(_) => return Ok(FailureStatus::Alive),
                    Err(_) => {
                        // 3. æ ‡è®°ä¸ºå¯ç–‘
                        self.gossip_protocol.mark_suspect(target).await?;
                        return Ok(FailureStatus::Suspect);
                    }
                }
            }
        }
    }
}
```

### 2. å®ç°æ•…éšœæ¢å¤

è‡ªåŠ¨æ£€æµ‹å’Œæ¢å¤æ•…éšœèŠ‚ç‚¹ã€‚

```rust
struct FailureRecoveryManager {
    failure_detector: MultiLevelFailureDetector,
    cluster_manager: ClusterManager,
    health_checker: HealthChecker,
}

impl FailureRecoveryManager {
    async fn start_recovery(&self) -> Result<(), Error> {
        let mut interval = tokio::time::interval(Duration::from_secs(30));
        
        loop {
            interval.tick().await;
            
            // æ£€æŸ¥æ•…éšœèŠ‚ç‚¹
            let failed_nodes = self.failure_detector.get_failed_nodes().await?;
            
            for node in failed_nodes {
                // å°è¯•æ¢å¤
                if self.health_checker.check_node(&node).await? {
                    // èŠ‚ç‚¹å·²æ¢å¤ï¼Œé‡æ–°åŠ å…¥é›†ç¾¤
                    self.cluster_manager.rejoin_node(node).await?;
                } else {
                    // èŠ‚ç‚¹ä»ç„¶æ•…éšœï¼Œè€ƒè™‘æ›¿æ¢
                    self.cluster_manager.replace_node(node).await?;
                }
            }
        }
    }
}
```

## âš–ï¸ è´Ÿè½½å‡è¡¡è®¾è®¡

> å‚è€ƒï¼šConsistent Hashingã€Jump Consistent Hashã€NGINX/Envoy ç­–ç•¥æ–‡æ¡£ã€‚

### 1. é€‰æ‹©åˆé€‚çš„è´Ÿè½½å‡è¡¡ç®—æ³•

æ ¹æ®åº”ç”¨ç‰¹ç‚¹é€‰æ‹©åˆé€‚çš„ç®—æ³•ã€‚

```rust
// è½®è¯¢ï¼šé€‚ç”¨äºæœåŠ¡èƒ½åŠ›ç›¸è¿‘çš„åœºæ™¯
struct RoundRobinBalancer {
    services: Vec<ServiceInstance>,
    current_index: AtomicUsize,
}

impl RoundRobinBalancer {
    fn select_server(&self) -> Option<&ServiceInstance> {
        let index = self.current_index.fetch_add(1, Ordering::SeqCst);
        self.services.get(index % self.services.len())
    }
}

// ä¸€è‡´æ€§å“ˆå¸Œï¼šé€‚ç”¨äºæœ‰çŠ¶æ€æœåŠ¡
struct ConsistentHashBalancer {
    ring: ConsistentHashRing,
    services: HashMap<String, ServiceInstance>,
}

impl ConsistentHashBalancer {
    fn select_server(&self, key: &str) -> Option<&ServiceInstance> {
        let node_id = self.ring.route(key)?;
        self.services.get(&node_id)
    }
}

// åŠ æƒè½®è¯¢ï¼šé€‚ç”¨äºæœåŠ¡èƒ½åŠ›ä¸åŒçš„åœºæ™¯
struct WeightedRoundRobinBalancer {
    services: Vec<WeightedService>,
    total_weight: u32,
    current_weight: AtomicU32,
}

impl WeightedRoundRobinBalancer {
    fn select_server(&self) -> Option<&ServiceInstance> {
        let current = self.current_weight.fetch_add(1, Ordering::SeqCst);
        let target_weight = current % self.total_weight;
        
        let mut accumulated_weight = 0;
        for service in &self.services {
            accumulated_weight += service.weight;
            if accumulated_weight > target_weight {
                return Some(&service.instance);
            }
        }
        
        None
    }
}
```

### 2. å®ç°å¥åº·æ£€æŸ¥

å®šæœŸæ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€ã€‚

```rust
struct HealthChecker {
    check_interval: Duration,
    timeout: Duration,
    max_failures: u32,
}

impl HealthChecker {
    async fn start_health_check(&self, services: &[ServiceInstance]) -> Result<(), Error> {
        let mut interval = tokio::time::interval(self.check_interval);
        
        loop {
            interval.tick().await;
            
            for service in services {
                let health_status = self.check_service_health(service).await;
                
                match health_status {
                    HealthStatus::Healthy => {
                        service.reset_failure_count();
                    }
                    HealthStatus::Unhealthy => {
                        service.increment_failure_count();
                        
                        if service.failure_count() >= self.max_failures {
                            service.mark_unhealthy();
                        }
                    }
                }
            }
        }
    }
    
    async fn check_service_health(&self, service: &ServiceInstance) -> HealthStatus {
        let client = reqwest::Client::new();
        
        match tokio::time::timeout(
            self.timeout,
            client.get(&format!("http://{}/health", service.address))
        ).await {
            Ok(response) => {
                if response.status().is_success() {
                    HealthStatus::Healthy
                } else {
                    HealthStatus::Unhealthy
                }
            }
            Err(_) => HealthStatus::Unhealthy,
        }
    }
}
```

## ğŸ›¡ï¸ å®‰å…¨è®¾è®¡

### 1. å®ç°è®¤è¯å’Œæˆæƒ

ç¡®ä¿åªæœ‰æˆæƒç”¨æˆ·æ‰èƒ½è®¿é—®ç³»ç»Ÿã€‚

```rust
struct AuthenticationManager {
    token_store: TokenStore,
    user_store: UserStore,
    jwt_secret: String,
}

impl AuthenticationManager {
    async fn authenticate(&self, token: &str) -> Result<User, Error> {
        // 1. éªŒè¯ JWT ä»¤ç‰Œ
        let claims = self.verify_jwt_token(token)?;
        
        // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
        let user = self.user_store.get_user(&claims.user_id).await?;
        
        // 3. æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
        if !user.is_active {
            return Err(Error::UserInactive);
        }
        
        Ok(user)
    }
    
    async fn authorize(&self, user: &User, resource: &str, action: &str) -> Result<bool, Error> {
        // æ£€æŸ¥ç”¨æˆ·æƒé™
        let permissions = self.user_store.get_permissions(&user.id).await?;
        
        for permission in permissions {
            if permission.resource == resource && permission.actions.contains(action) {
                return Ok(true);
            }
        }
        
        Ok(false)
    }
}
```

### 2. å®ç°æ•°æ®åŠ å¯†

ä¿æŠ¤æ•æ„Ÿæ•°æ®ã€‚

```rust
struct EncryptionManager {
    encryption_key: [u8; 32],
    hmac_key: [u8; 32],
}

impl EncryptionManager {
    fn encrypt(&self, plaintext: &[u8]) -> Result<Vec<u8>, Error> {
        use aes_gcm::{Aes256Gcm, Key, Nonce};
        use aes_gcm::aead::{Aead, NewAead};
        
        let key = Key::from_slice(&self.encryption_key);
        let cipher = Aes256Gcm::new(key);
        
        // ç”Ÿæˆéšæœº nonce
        let nonce = Nonce::from_slice(b"unique nonce");
        
        // åŠ å¯†
        let ciphertext = cipher.encrypt(nonce, plaintext)
            .map_err(|_| Error::EncryptionFailed)?;
        
        // è®¡ç®— HMAC
        let hmac = self.calculate_hmac(&ciphertext)?;
        
        // ç»„åˆç»“æœ
        let mut result = Vec::new();
        result.extend_from_slice(&ciphertext);
        result.extend_from_slice(&hmac);
        
        Ok(result)
    }
    
    fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, Error> {
        use aes_gcm::{Aes256Gcm, Key, Nonce};
        use aes_gcm::aead::{Aead, NewAead};
        
        // åˆ†ç¦»å¯†æ–‡å’Œ HMAC
        let (encrypted_data, hmac) = ciphertext.split_at(ciphertext.len() - 32);
        
        // éªŒè¯ HMAC
        let expected_hmac = self.calculate_hmac(encrypted_data)?;
        if hmac != &expected_hmac {
            return Err(Error::AuthenticationFailed);
        }
        
        // è§£å¯†
        let key = Key::from_slice(&self.encryption_key);
        let cipher = Aes256Gcm::new(key);
        let nonce = Nonce::from_slice(b"unique nonce");
        
        let plaintext = cipher.decrypt(nonce, encrypted_data)
            .map_err(|_| Error::DecryptionFailed)?;
        
        Ok(plaintext)
    }
}
```

## ğŸ“Š ç›‘æ§è®¾è®¡

> å‚è€ƒï¼šPrometheusã€OpenTelemetryã€USE/RED æ–¹æ³•è®ºã€‚

### 1. å®ç°æŒ‡æ ‡æ”¶é›†

æ”¶é›†å…³é”®ä¸šåŠ¡å’ŒæŠ€æœ¯æŒ‡æ ‡ã€‚

```rust
struct MetricsCollector {
    counters: HashMap<String, AtomicU64>,
    histograms: HashMap<String, Histogram>,
    gauges: HashMap<String, AtomicU64>,
}

impl MetricsCollector {
    fn increment_counter(&self, name: &str, value: u64) {
        if let Some(counter) = self.counters.get(name) {
            counter.fetch_add(value, Ordering::SeqCst);
        }
    }
    
    fn record_histogram(&self, name: &str, value: f64) {
        if let Some(histogram) = self.histograms.get(name) {
            histogram.observe(value);
        }
    }
    
    fn set_gauge(&self, name: &str, value: u64) {
        if let Some(gauge) = self.gauges.get(name) {
            gauge.store(value, Ordering::SeqCst);
        }
    }
    
    async fn export_metrics(&self) -> Result<Vec<u8>, Error> {
        let mut metrics = Vec::new();
        
        // å¯¼å‡ºè®¡æ•°å™¨
        for (name, counter) in &self.counters {
            let value = counter.load(Ordering::SeqCst);
            metrics.push(format!("{}_total {}", name, value));
        }
        
        // å¯¼å‡ºç›´æ–¹å›¾
        for (name, histogram) in &self.histograms {
            let stats = histogram.get_stats();
            metrics.push(format!("{}_count {}", name, stats.count));
            metrics.push(format!("{}_sum {}", name, stats.sum));
            metrics.push(format!("{}_bucket {}", name, stats.buckets));
        }
        
        // å¯¼å‡ºä»ªè¡¨
        for (name, gauge) in &self.gauges {
            let value = gauge.load(Ordering::SeqCst);
            metrics.push(format!("{} {}", name, value));
        }
        
        Ok(metrics.join("\n").into_bytes())
    }
}
```

### 2. å®ç°é“¾è·¯è¿½è¸ª

è¿½è¸ªè¯·æ±‚åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä¼ æ’­ã€‚

```rust
struct DistributedTracer {
    tracer: Tracer,
    propagator: TextMapPropagator,
}

impl DistributedTracer {
    fn start_span(&self, name: &str) -> Span {
        self.tracer.start_span(name)
    }
    
    fn inject_context(&self, span: &Span, headers: &mut HashMap<String, String>) {
        let mut carrier = HashMap::new();
        self.propagator.inject_context(&span.context(), &mut carrier);
        
        for (key, value) in carrier {
            headers.insert(key, value);
        }
    }
    
    fn extract_context(&self, headers: &HashMap<String, String>) -> Option<SpanContext> {
        let carrier = headers.iter().map(|(k, v)| (k.as_str(), v.as_str())).collect();
        self.propagator.extract_context(&carrier)
    }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. å®ç°è¿æ¥æ± 

å¤ç”¨è¿æ¥ï¼Œå‡å°‘è¿æ¥å¼€é”€ã€‚

```rust
struct ConnectionPool {
    connections: Arc<Mutex<Vec<Connection>>>,
    max_size: usize,
    min_size: usize,
    idle_timeout: Duration,
}

impl ConnectionPool {
    async fn get_connection(&self) -> Result<Connection, Error> {
        let mut connections = self.connections.lock().await;
        
        // å°è¯•ä»æ± ä¸­è·å–è¿æ¥
        if let Some(connection) = connections.pop() {
            if connection.is_healthy() {
                return Ok(connection);
            }
        }
        
        // åˆ›å»ºæ–°è¿æ¥
        let connection = Connection::new().await?;
        Ok(connection)
    }
    
    async fn return_connection(&self, mut connection: Connection) {
        if connection.is_healthy() {
            let mut connections = self.connections.lock().await;
            
            if connections.len() < self.max_size {
                connections.push(connection);
            }
        }
    }
}
```

### 2. å®ç°æ‰¹å¤„ç†

æ‰¹é‡å¤„ç†æ“ä½œï¼Œæé«˜ååé‡ã€‚

```rust
struct BatchProcessor<T> {
    batch_size: usize,
    batch_timeout: Duration,
    processor: Arc<dyn Fn(Vec<T>) -> Result<(), Error> + Send + Sync>,
    pending_items: Arc<Mutex<Vec<T>>>,
}

impl<T> BatchProcessor<T> {
    async fn process_item(&self, item: T) -> Result<(), Error> {
        let mut pending = self.pending_items.lock().await;
        pending.push(item);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦ç«‹å³å¤„ç†
        if pending.len() >= self.batch_size {
            let items = pending.drain(..).collect();
            drop(pending);
            
            (self.processor)(items)?;
        }
        
        Ok(())
    }
    
    async fn start_batch_processor(&self) -> Result<(), Error> {
        let mut interval = tokio::time::interval(self.batch_timeout);
        
        loop {
            interval.tick().await;
            
            let mut pending = self.pending_items.lock().await;
            if !pending.is_empty() {
                let items = pending.drain(..).collect();
                drop(pending);
                
                (self.processor)(items)?;
            }
        }
    }
}
```

## ğŸ”— ç›¸å…³èµ„æº

- [å¿«é€Ÿå¼€å§‹æŒ‡å—](../QUICKSTART.md)
- [ä¸€è‡´æ€§æ¨¡å‹è¯¦è§£](../consistency/README.md)
- [å…±è¯†ç®—æ³•å®ç°](../consensus/README.md)
- [æµ‹è¯•ç­–ç•¥](../testing/README.md)
- [æ€§èƒ½ä¼˜åŒ–æŠ€å·§](../performance/OPTIMIZATION.md)

## ğŸ†˜ è·å–å¸®åŠ©

- **GitHub Issues**: [æŠ¥å‘Šé—®é¢˜](https://github.com/your-org/c20_distributed/issues)
- **Discussions**: [è®¨è®ºäº¤æµ](https://github.com/your-org/c20_distributed/discussions)
- **Stack Overflow**: [æŠ€æœ¯é—®ç­”](https://stackoverflow.com/questions/tagged/c20-distributed)

---

**éµå¾ªæœ€ä½³å®è·µï¼** ğŸš€ åº”ç”¨è¿™äº›è®¾è®¡åŸåˆ™å’Œæ¨¡å¼ï¼Œæ„å»ºå¯é ã€é«˜æ€§èƒ½çš„åˆ†å¸ƒå¼ç³»ç»Ÿã€‚
