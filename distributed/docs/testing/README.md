# æµ‹è¯•ç­–ç•¥æŒ‡å—

æœ¬æ–‡æ¡£æä¾›äº†åˆ†å¸ƒå¼ç³»ç»Ÿæµ‹è¯•çš„å…¨é¢æŒ‡å—ï¼ŒåŒ…æ‹¬æµ‹è¯•ç­–ç•¥ã€æµ‹è¯•ç±»å‹ã€æµ‹è¯•å·¥å…·å’Œæœ€ä½³å®è·µã€‚

## ç›®å½•

- [æµ‹è¯•ç­–ç•¥æŒ‡å—](#æµ‹è¯•ç­–ç•¥æŒ‡å—)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ¯ æµ‹è¯•ç­–ç•¥æ¦‚è§ˆ](#-æµ‹è¯•ç­–ç•¥æ¦‚è§ˆ)
    - [æµ‹è¯•é‡‘å­—å¡”](#æµ‹è¯•é‡‘å­—å¡”)
    - [æµ‹è¯•ç±»å‹åˆ†å¸ƒ](#æµ‹è¯•ç±»å‹åˆ†å¸ƒ)
  - [ğŸ”§ å•å…ƒæµ‹è¯•](#-å•å…ƒæµ‹è¯•)
    - [1. åŸºç¡€å•å…ƒæµ‹è¯•](#1-åŸºç¡€å•å…ƒæµ‹è¯•)
    - [2. å±æ€§æµ‹è¯•](#2-å±æ€§æµ‹è¯•)
    - [3. æ¨¡æ‹Ÿæµ‹è¯•](#3-æ¨¡æ‹Ÿæµ‹è¯•)
  - [ğŸ”— é›†æˆæµ‹è¯•](#-é›†æˆæµ‹è¯•)
    - [1. ç»„ä»¶é›†æˆæµ‹è¯•](#1-ç»„ä»¶é›†æˆæµ‹è¯•)
    - [2. åˆ†å¸ƒå¼äº‹åŠ¡é›†æˆæµ‹è¯•](#2-åˆ†å¸ƒå¼äº‹åŠ¡é›†æˆæµ‹è¯•)
  - [ğŸŒ ç«¯åˆ°ç«¯æµ‹è¯•](#-ç«¯åˆ°ç«¯æµ‹è¯•)
    - [1. å®Œæ•´æµç¨‹æµ‹è¯•](#1-å®Œæ•´æµç¨‹æµ‹è¯•)
    - [2. æ•…éšœæ¢å¤æµ‹è¯•](#2-æ•…éšœæ¢å¤æµ‹è¯•)
  - [ğŸ§ª æ··æ²Œæµ‹è¯•](#-æ··æ²Œæµ‹è¯•)
    - [1. æ•…éšœæ³¨å…¥æµ‹è¯•](#1-æ•…éšœæ³¨å…¥æµ‹è¯•)
    - [2. ç½‘ç»œåˆ†åŒºæµ‹è¯•](#2-ç½‘ç»œåˆ†åŒºæµ‹è¯•)
  - [ğŸ“Š æ€§èƒ½æµ‹è¯•](#-æ€§èƒ½æµ‹è¯•)
    - [1. å»¶è¿Ÿæµ‹è¯•](#1-å»¶è¿Ÿæµ‹è¯•)
    - [2. ååé‡æµ‹è¯•](#2-ååé‡æµ‹è¯•)
  - [ğŸ” ä¸€è‡´æ€§æµ‹è¯•](#-ä¸€è‡´æ€§æµ‹è¯•)
    - [1. çº¿æ€§åŒ–æµ‹è¯•](#1-çº¿æ€§åŒ–æµ‹è¯•)
    - [2. æœ€ç»ˆä¸€è‡´æ€§æµ‹è¯•](#2-æœ€ç»ˆä¸€è‡´æ€§æµ‹è¯•)
  - [ğŸ› ï¸ æµ‹è¯•å·¥å…·](#ï¸-æµ‹è¯•å·¥å…·)
    - [1. æµ‹è¯•é›†ç¾¤](#1-æµ‹è¯•é›†ç¾¤)
    - [2. æ··æ²Œå¼•æ“](#2-æ··æ²Œå¼•æ“)
  - [ğŸ“‹ æµ‹è¯•æœ€ä½³å®è·µ](#-æµ‹è¯•æœ€ä½³å®è·µ)
    - [1. æµ‹è¯•ç»„ç»‡](#1-æµ‹è¯•ç»„ç»‡)
    - [2. æµ‹è¯•æ•°æ®ç®¡ç†](#2-æµ‹è¯•æ•°æ®ç®¡ç†)
    - [3. æµ‹è¯•ç¯å¢ƒéš”ç¦»](#3-æµ‹è¯•ç¯å¢ƒéš”ç¦»)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
  - [ğŸ†˜ è·å–å¸®åŠ©](#-è·å–å¸®åŠ©)


## ğŸ¯ æµ‹è¯•ç­–ç•¥æ¦‚è§ˆ

### æµ‹è¯•é‡‘å­—å¡”

```text
    /\
   /  \
  /E2E \    ç«¯åˆ°ç«¯æµ‹è¯• (5%)
 /______\
/        \
/é›†æˆæµ‹è¯• \  é›†æˆæµ‹è¯• (15%)
/__________\
/            \
/  å•å…ƒæµ‹è¯•   \  å•å…ƒæµ‹è¯• (80%)
/______________\
```

### æµ‹è¯•ç±»å‹åˆ†å¸ƒ

- **å•å…ƒæµ‹è¯• (80%)**: å¿«é€Ÿã€éš”ç¦»ã€å¯é‡å¤
- **é›†æˆæµ‹è¯• (15%)**: æµ‹è¯•ç»„ä»¶é—´äº¤äº’
- **ç«¯åˆ°ç«¯æµ‹è¯• (5%)**: éªŒè¯å®Œæ•´ç”¨æˆ·æµç¨‹

## ğŸ”§ å•å…ƒæµ‹è¯•

### 1. åŸºç¡€å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use c20_distributed::replication::LocalReplicator;
    use c20_distributed::consistency::ConsistencyLevel;
    
    #[tokio::test]
    async fn test_replication_success() {
        let replicator = LocalReplicator::new(3, 2, 2);
        
        let result = replicator.replicate("key1", "value1", ConsistencyLevel::Quorum).await;
        assert!(result.is_ok());
        
        let value = replicator.read("key1", ConsistencyLevel::Quorum).await;
        assert_eq!(value, Ok(Some("value1".to_string())));
    }
    
    #[tokio::test]
    async fn test_quorum_calculation() {
        let replicator = LocalReplicator::new(5, 3, 3);
        
        // æµ‹è¯•æ³•å®šäººæ•°è®¡ç®—
        assert_eq!(replicator.calculate_quorum(5), 3);
        assert_eq!(replicator.calculate_quorum(3), 2);
        assert_eq!(replicator.calculate_quorum(7), 4);
    }
}
```

### 2. å±æ€§æµ‹è¯•

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_quorum_properties(
        nodes in 3..=10usize,
        consistency in any::<ConsistencyLevel>()
    ) {
        let replicator = LocalReplicator::new(nodes, consistency);
        
        // å±æ€§1: æ³•å®šäººæ•°å¿…é¡»å¤§äºèŠ‚ç‚¹æ•°çš„ä¸€åŠ
        prop_assert!(replicator.required_acks() > nodes / 2);
        
        // å±æ€§2: æ³•å®šäººæ•°ä¸èƒ½è¶…è¿‡èŠ‚ç‚¹æ€»æ•°
        prop_assert!(replicator.required_acks() <= nodes);
    }
}
```

### 3. æ¨¡æ‹Ÿæµ‹è¯•

```rust
use mockall::*;

#[automock]
trait StorageBackend {
    async fn get(&self, key: &str) -> Result<Option<Vec<u8>>, Error>;
    async fn put(&self, key: &str, value: &[u8]) -> Result<(), Error>;
}

#[tokio::test]
async fn test_replicator_with_mock_storage() {
    let mut mock_storage = MockStorageBackend::new();
    
    mock_storage
        .expect_get()
        .with(eq("key1"))
        .times(1)
        .returning(|| Ok(Some(b"value1".to_vec())));
    
    let replicator = LocalReplicator::new_with_storage(Box::new(mock_storage));
    
    let result = replicator.replicate("key1", "value1", ConsistencyLevel::Quorum).await;
    assert!(result.is_ok());
}
```

## ğŸ”— é›†æˆæµ‹è¯•

### 1. ç»„ä»¶é›†æˆæµ‹è¯•

```rust
#[tokio::test]
async fn test_replication_and_consensus_integration() {
    let mut cluster = TestCluster::new(5).await;
    
    // æµ‹è¯•å¤åˆ¶å’Œå…±è¯†çš„é›†æˆ
    let result = cluster.write("key1", "value1").await;
    assert!(result.is_ok());
    
    // ç­‰å¾…å…±è¯†
    cluster.wait_for_consensus().await;
    
    // éªŒè¯æ‰€æœ‰èŠ‚ç‚¹éƒ½æœ‰ç›¸åŒçš„æ•°æ®
    for node in cluster.nodes() {
        let value = node.read("key1").await;
        assert_eq!(value, Some("value1".to_string()));
    }
}
```

### 2. åˆ†å¸ƒå¼äº‹åŠ¡é›†æˆæµ‹è¯•

```rust
#[tokio::test]
async fn test_saga_transaction_integration() {
    let mut saga = Saga::new();
    
    // æ·»åŠ äº‹åŠ¡æ­¥éª¤
    saga.add_step(Box::new(PaymentStep::new("user1", 100)));
    saga.add_step(Box::new(InventoryStep::new("product1", 1)));
    
    // æµ‹è¯•æˆåŠŸåœºæ™¯
    let result = saga.execute().await;
    assert!(result.is_ok());
    
    // éªŒè¯æ‰€æœ‰æ­¥éª¤éƒ½æ‰§è¡ŒæˆåŠŸ
    assert!(saga.all_steps_completed());
}
```

## ğŸŒ ç«¯åˆ°ç«¯æµ‹è¯•

### 1. å®Œæ•´æµç¨‹æµ‹è¯•

```rust
#[tokio::test]
async fn test_complete_user_journey() {
    let cluster = TestCluster::new(7).await;
    let client = TestClient::new(cluster);
    
    // 1. ç”¨æˆ·æ³¨å†Œ
    let user = client.register_user("alice", "password123").await.unwrap();
    assert_eq!(user.username, "alice");
    
    // 2. ç”¨æˆ·ç™»å½•
    let session = client.login("alice", "password123").await.unwrap();
    assert!(session.is_valid());
    
    // 3. åˆ›å»ºè®¢å•
    let order = client.create_order(&session, vec![
        OrderItem { product_id: "product1", quantity: 2 },
    ]).await.unwrap();
    
    // 4. æ”¯ä»˜è®¢å•
    let payment = client.pay_order(&session, &order.id, 100.0).await.unwrap();
    assert_eq!(payment.status, PaymentStatus::Completed);
}
```

### 2. æ•…éšœæ¢å¤æµ‹è¯•

```rust
#[tokio::test]
async fn test_failure_recovery() {
    let mut cluster = TestCluster::new(5).await;
    let client = TestClient::new(cluster.clone());
    
    // 1. æ­£å¸¸æ“ä½œ
    let result = client.write("key1", "value1").await;
    assert!(result.is_ok());
    
    // 2. æ¨¡æ‹ŸèŠ‚ç‚¹æ•…éšœ
    cluster.kill_node("node1").await;
    
    // 3. éªŒè¯ç³»ç»Ÿä»ç„¶å¯ç”¨
    let result = client.write("key2", "value2").await;
    assert!(result.is_ok());
    
    // 4. æ¢å¤èŠ‚ç‚¹
    cluster.restart_node("node1").await;
    
    // 5. éªŒè¯æ•°æ®ä¸€è‡´æ€§
    cluster.wait_for_consistency().await;
}
```

## ğŸ§ª æ··æ²Œæµ‹è¯•

### 1. æ•…éšœæ³¨å…¥æµ‹è¯•

```rust
#[tokio::test]
async fn test_chaos_engineering() {
    let mut cluster = TestCluster::new(5).await;
    let chaos_engine = ChaosEngine::new(cluster.clone());
    
    let fault_scenarios = vec![
        FaultScenario::NodeCrash,
        FaultScenario::NetworkPartition,
        FaultScenario::MessageLoss,
    ];
    
    for scenario in fault_scenarios {
        // æ³¨å…¥æ•…éšœ
        chaos_engine.inject_fault(scenario).await;
        
        // ç­‰å¾…ç³»ç»Ÿç¨³å®š
        tokio::time::sleep(Duration::from_secs(5)).await;
        
        // éªŒè¯ç³»ç»Ÿä»ç„¶å¯ç”¨
        let result = cluster.write("test_key", "test_value").await;
        assert!(result.is_ok());
        
        // æ¢å¤æ•…éšœ
        chaos_engine.recover_fault(scenario).await;
        
        // éªŒè¯ç³»ç»Ÿæ¢å¤
        cluster.wait_for_consistency().await;
    }
}
```

### 2. ç½‘ç»œåˆ†åŒºæµ‹è¯•

```rust
#[tokio::test]
async fn test_network_partition() {
    let mut cluster = TestCluster::new(5).await;
    
    // 1. åˆ›å»ºç½‘ç»œåˆ†åŒº
    cluster.partition(vec![0, 1], vec![2, 3, 4]).await;
    
    // 2. éªŒè¯å¤šæ•°æ´¾åˆ†åŒºå¯ä»¥ç»§ç»­æ“ä½œ
    let majority_partition = cluster.get_partition(vec![2, 3, 4]);
    let result = majority_partition.write("key1", "value1").await;
    assert!(result.is_ok());
    
    // 3. éªŒè¯å°‘æ•°æ´¾åˆ†åŒºä¸èƒ½æ“ä½œ
    let minority_partition = cluster.get_partition(vec![0, 1]);
    let result = minority_partition.write("key2", "value2").await;
    assert!(result.is_err());
    
    // 4. æ¢å¤ç½‘ç»œåˆ†åŒº
    cluster.heal_partition().await;
    
    // 5. éªŒè¯æ•°æ®ä¸€è‡´æ€§
    cluster.wait_for_consistency().await;
}
```

## ğŸ“Š æ€§èƒ½æµ‹è¯•

### 1. å»¶è¿Ÿæµ‹è¯•

```rust
#[tokio::test]
async fn test_latency_performance() {
    let cluster = TestCluster::new(5).await;
    let client = TestClient::new(cluster);
    
    let mut latencies = Vec::new();
    
    // æµ‹é‡å»¶è¿Ÿ
    for i in 0..1000 {
        let start = Instant::now();
        let result = client.write(&format!("key_{}", i), &format!("value_{}", i)).await;
        let latency = start.elapsed();
        
        assert!(result.is_ok());
        latencies.push(latency);
    }
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    latencies.sort();
    let p50 = latencies[500];
    let p95 = latencies[950];
    let p99 = latencies[990];
    
    println!("P50 å»¶è¿Ÿ: {:?}", p50);
    println!("P95 å»¶è¿Ÿ: {:?}", p95);
    println!("P99 å»¶è¿Ÿ: {:?}", p99);
    
    // éªŒè¯æ€§èƒ½è¦æ±‚
    assert!(p50 < Duration::from_millis(10));
    assert!(p95 < Duration::from_millis(50));
    assert!(p99 < Duration::from_millis(100));
}
```

### 2. ååé‡æµ‹è¯•

```rust
#[tokio::test]
async fn test_throughput_performance() {
    let cluster = TestCluster::new(5).await;
    let client = TestClient::new(cluster);
    
    let start = Instant::now();
    let mut handles = Vec::new();
    
    // å¯åŠ¨å¤šä¸ªå¹¶å‘å®¢æˆ·ç«¯
    for i in 0..100 {
        let client = client.clone();
        let handle = tokio::spawn(async move {
            let mut count = 0;
            for j in 0..100 {
                let result = client.write(&format!("key_{}_{}", i, j), &format!("value_{}_{}", i, j)).await;
                if result.is_ok() {
                    count += 1;
                }
            }
            count
        });
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰å®¢æˆ·ç«¯å®Œæˆ
    let mut total_operations = 0;
    for handle in handles {
        total_operations += handle.await.unwrap();
    }
    
    let duration = start.elapsed();
    let throughput = total_operations as f64 / duration.as_secs_f64();
    
    println!("æ€»æ“ä½œæ•°: {}", total_operations);
    println!("æ€»æ—¶é—´: {:?}", duration);
    println!("ååé‡: {:.2} OPS", throughput);
    
    // éªŒè¯æ€§èƒ½è¦æ±‚
    assert!(throughput > 1000.0);
}
```

## ğŸ” ä¸€è‡´æ€§æµ‹è¯•

### 1. çº¿æ€§åŒ–æµ‹è¯•

```rust
#[tokio::test]
async fn test_linearizability() {
    let cluster = TestCluster::new(5).await;
    let client = TestClient::new(cluster);
    
    let mut operations = Vec::new();
    
    // ç”Ÿæˆå¹¶å‘æ“ä½œ
    for i in 0..100 {
        let client = client.clone();
        let handle = tokio::spawn(async move {
            let start = Instant::now();
            let result = client.write(&format!("key_{}", i), &format!("value_{}", i)).await;
            let end = Instant::now();
            
            Operation {
                id: i,
                start_time: start,
                end_time: end,
                operation_type: OperationType::Write,
                key: format!("key_{}", i),
                value: Some(format!("value_{}", i)),
                result: result.is_ok(),
            }
        });
        operations.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰æ“ä½œå®Œæˆ
    let mut operation_history = Vec::new();
    for handle in operations {
        operation_history.push(handle.await.unwrap());
    }
    
    // éªŒè¯çº¿æ€§åŒ–
    let checker = LinearizabilityChecker::new();
    let is_linearizable = checker.verify(&operation_history);
    
    assert!(is_linearizable);
}
```

### 2. æœ€ç»ˆä¸€è‡´æ€§æµ‹è¯•

```rust
#[tokio::test]
async fn test_eventual_consistency() {
    let cluster = TestCluster::new(5).await;
    let client = TestClient::new(cluster);
    
    // å†™å…¥æ•°æ®
    let result = client.write("key1", "value1").await;
    assert!(result.is_ok());
    
    // ç­‰å¾…æœ€ç»ˆä¸€è‡´æ€§
    let mut attempts = 0;
    let max_attempts = 100;
    
    while attempts < max_attempts {
        let mut consistent = true;
        
        for node in cluster.nodes() {
            let value = node.read("key1").await;
            if value != Some("value1".to_string()) {
                consistent = false;
                break;
            }
        }
        
        if consistent {
            break;
        }
        
        tokio::time::sleep(Duration::from_millis(100)).await;
        attempts += 1;
    }
    
    assert!(attempts < max_attempts, "æœ€ç»ˆä¸€è‡´æ€§æœªè¾¾æˆ");
}
```

## ğŸ› ï¸ æµ‹è¯•å·¥å…·

### 1. æµ‹è¯•é›†ç¾¤

```rust
pub struct TestCluster {
    nodes: Vec<TestNode>,
    load_balancer: LoadBalancer,
    failure_detector: FailureDetector,
}

impl TestCluster {
    pub async fn new(node_count: usize) -> Self {
        let mut nodes = Vec::new();
        
        for i in 0..node_count {
            let node = TestNode::new(format!("node_{}", i)).await;
            nodes.push(node);
        }
        
        let load_balancer = LoadBalancer::new(nodes.clone());
        let failure_detector = FailureDetector::new(nodes.clone());
        
        Self {
            nodes,
            load_balancer,
            failure_detector,
        }
    }
    
    pub async fn write(&self, key: &str, value: &str) -> Result<(), Error> {
        self.load_balancer.select_server()
            .ok_or(Error::NoAvailableServers)?
            .write(key, value)
            .await
    }
    
    pub async fn kill_node(&mut self, node_id: &str) {
        if let Some(node) = self.nodes.iter_mut().find(|n| n.id == node_id) {
            node.kill().await;
        }
    }
    
    pub async fn restart_node(&mut self, node_id: &str) {
        if let Some(node) = self.nodes.iter_mut().find(|n| n.id == node_id) {
            node.restart().await;
        }
    }
    
    pub async fn wait_for_consistency(&self) {
        let mut consistent = false;
        
        while !consistent {
            consistent = true;
            
            for i in 0..self.nodes.len() {
                for j in i+1..self.nodes.len() {
                    if !self.nodes[i].is_consistent_with(&self.nodes[j]).await {
                        consistent = false;
                        break;
                    }
                }
                if !consistent {
                    break;
                }
            }
            
            if !consistent {
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        }
    }
}
```

### 2. æ··æ²Œå¼•æ“

```rust
pub struct ChaosEngine {
    cluster: TestCluster,
    fault_injectors: Vec<Box<dyn FaultInjector>>,
}

impl ChaosEngine {
    pub fn new(cluster: TestCluster) -> Self {
        let fault_injectors: Vec<Box<dyn FaultInjector>> = vec![
            Box::new(NodeCrashInjector::new()),
            Box::new(NetworkPartitionInjector::new()),
            Box::new(MessageLossInjector::new()),
        ];
        
        Self {
            cluster,
            fault_injectors,
        }
    }
    
    pub async fn inject_fault(&mut self, scenario: FaultScenario) {
        for injector in &mut self.fault_injectors {
            if injector.can_inject(scenario) {
                injector.inject(&mut self.cluster, scenario).await;
                break;
            }
        }
    }
    
    pub async fn recover_fault(&mut self, scenario: FaultScenario) {
        for injector in &mut self.fault_injectors {
            if injector.can_inject(scenario) {
                injector.recover(&mut self.cluster, scenario).await;
                break;
            }
        }
    }
}
```

## ğŸ“‹ æµ‹è¯•æœ€ä½³å®è·µ

### 1. æµ‹è¯•ç»„ç»‡

```rust
// æµ‹è¯•æ¨¡å—ç»„ç»‡
#[cfg(test)]
mod tests {
    // å•å…ƒæµ‹è¯•
    mod unit_tests {
        use super::*;
        
        #[tokio::test]
        async fn test_basic_functionality() {
            // æµ‹è¯•åŸºæœ¬åŠŸèƒ½
        }
    }
    
    // é›†æˆæµ‹è¯•
    mod integration_tests {
        use super::*;
        
        #[tokio::test]
        async fn test_component_integration() {
            // æµ‹è¯•ç»„ä»¶é›†æˆ
        }
    }
    
    // æ€§èƒ½æµ‹è¯•
    mod performance_tests {
        use super::*;
        
        #[tokio::test]
        async fn test_performance() {
            // æµ‹è¯•æ€§èƒ½
        }
    }
}
```

### 2. æµ‹è¯•æ•°æ®ç®¡ç†

```rust
// æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
pub struct TestDataGenerator;

impl TestDataGenerator {
    pub fn generate_user() -> User {
        User {
            id: Uuid::new_v4(),
            username: format!("user_{}", rand::random::<u32>()),
            email: format!("user_{}@example.com", rand::random::<u32>()),
            created_at: Utc::now(),
        }
    }
    
    pub fn generate_order(user_id: Uuid) -> Order {
        Order {
            id: Uuid::new_v4(),
            user_id,
            items: vec![
                OrderItem {
                    product_id: format!("product_{}", rand::random::<u32>()),
                    quantity: rand::random::<u32>() % 10 + 1,
                }
            ],
            total_amount: rand::random::<f64>() * 1000.0,
            status: OrderStatus::Pending,
        }
    }
}
```

### 3. æµ‹è¯•ç¯å¢ƒéš”ç¦»

```rust
// æµ‹è¯•ç¯å¢ƒé…ç½®
pub struct TestEnvironment {
    pub database_url: String,
    pub redis_url: String,
    pub port: u16,
}

impl TestEnvironment {
    pub async fn setup() -> Self {
        // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
        let port = find_free_port().await;
        let database_url = format!("sqlite://test_{}.db", Uuid::new_v4());
        let redis_url = format!("redis://localhost:{}/0", port);
        
        Self {
            database_url,
            redis_url,
            port,
        }
    }
    
    pub async fn cleanup(&self) {
        // æ¸…ç†æµ‹è¯•ç¯å¢ƒ
        tokio::fs::remove_file(&self.database_url).await.ok();
    }
}
```

## ğŸ”— ç›¸å…³èµ„æº

- [å¿«é€Ÿå¼€å§‹æŒ‡å—](../QUICKSTART.md)
- [ç³»ç»Ÿè®¾è®¡æœ€ä½³å®è·µ](../design/BEST_PRACTICES.md)
- [æ€§èƒ½ä¼˜åŒ–æŠ€å·§](../performance/OPTIMIZATION.md)
- [å®éªŒæ£€æŸ¥æ¸…å•](../experiments/CHECKLIST.md)
- [å¸¸è§é™·é˜±ä¸è°ƒè¯•](../PITFALLS.md)

## ğŸ†˜ è·å–å¸®åŠ©

- **GitHub Issues**: [æŠ¥å‘Šé—®é¢˜](https://github.com/your-org/c20_distributed/issues)
- **Discussions**: [è®¨è®ºäº¤æµ](https://github.com/your-org/c20_distributed/discussions)
- **Stack Overflow**: [æŠ€æœ¯é—®ç­”](https://stackoverflow.com/questions/tagged/c20-distributed)

---

**æµ‹è¯•é©±åŠ¨å¼€å‘ï¼** ğŸš€ å»ºç«‹å®Œå–„çš„æµ‹è¯•ä½“ç³»ï¼Œç¡®ä¿åˆ†å¸ƒå¼ç³»ç»Ÿçš„å¯é æ€§å’Œç¨³å®šæ€§ã€‚
